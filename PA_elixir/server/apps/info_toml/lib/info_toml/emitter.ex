# info_toml/emitter.ex

defmodule InfoToml.Emitter do
#
# Public functions
#
#   emit_toml/2
#     Emit a TOML file.  Return path to the file.
#   get_item_toml/2
#     Generate an IO list containing TOML for `item_map`.
#
# Private functions
#
#   get_file_path/1
#     Generate a file name, based on the current date and time.
#   reorder_bases/1
#     Reorder the bases, so that `meta` (etc) move to the front.

  @moduledoc """
  This module emits Maps (e.g., for items) in our flavor of TOML.
  """

  use InfoToml.Types

# import Common, only: [ii: 2]
  import Common, only: [keyss: 1]

  # Public functions

  @doc """
  Emit a TOML file.  Return the absolute file path.

  Note: The file names generated by `get_file_path/1` are not unique:
  it is possible (though unlikely!) for multiple submission requests
  to come in at the same microsecond.  As a kludgy workaround for this
  eventuality, we write the data in append mode.  With luck, this will
  simply result in a concatenated set of entries.  Of course, if the IO
  subsystem decides to interleave the data, things could get ugly...
  """
  @spec emit_toml(s, any) :: s when s: String.t

  def emit_toml(base_path, toml_text) do

    file_path   = get_file_path(base_path)
    toml_out    = "#{ toml_text }\n\n\n"

    {:ok, file} = File.open(file_path, [:write, :append])
    IO.binwrite(file, toml_out)
    File.close(file)

    file_path
  end

  @doc """
  Generate TOML for an item.  Specifically, create an IO list containing
  TOML for `item_map`.  Because we want the result to be attractive and
  readable, we spend some effort on formatting.  For example, we align the
  equal signs (=) and use `gi_bases` to control the order of presentation.
  """

  @spec get_item_toml([ [atom] ], map) :: [String.t]

  def get_item_toml(gi_bases, item_map) do

    map_fn    = fn gi_base ->
      base_str  = Enum.join(gi_base, ".")
      part_hdr  = [ "\n[ #{ base_str } ]\n\n" ]
      part_map  = get_in(item_map, gi_base)

      reduce_fn = fn key_atom, acc ->
        leaf_val  = part_map[key_atom]
        key_str   = to_string(key_atom)
        
        if is_map(leaf_val) do
          acc
        else
          padded_key  = String.pad_trailing(key_str, 11)
          key_etc     = "  #{ padded_key } = "
          val_etc     = cond do
            String.contains?(leaf_val, "\n") ->
              tidied  = leaf_val
              |> String.replace(~r{ \r }x, "")
              |> String.trim_trailing()

              "'''\n#{ tidied }\n'''\n"
            String.contains?(leaf_val, "'") ->
              "\"#{ leaf_val }\"\n"
            true  ->
              "'#{ leaf_val }'\n"
          end

          [ val_etc, key_etc | acc ]
        end
      end

      part_map
      |> keyss()
      |> Enum.reduce(part_hdr, reduce_fn)
      |> Enum.reverse()
    end

    reject_fn   = fn gi_base -> gi_base == [ :address ] end

    toml_body   = gi_bases
    |> reorder_bases()
    |> Enum.reject(reject_fn)
    |> Enum.reverse()
    |> Enum.map(map_fn)
    |> Enum.reverse()

    id_str      = get_in(item_map, [:meta, :id_str])
    toml_hdr    = "# #{ id_str }/main.toml\n"

    [ toml_hdr, toml_body, "\n" ]
  end

  # Private Functions

  @spec get_file_path(s) :: s when s: String.t

  defp get_file_path(base_path) do
  #
  # Generate a file name (eg, `2019-02-23T04:44:36.315737Z.toml`), based
  # on the current (ISO 8601) date and time.  If need be, generate a
  # sharding directory based on the date and hour (eg, `2019-02-23T04`).
  # Finally, return the full path name for the file.
  #
  # Note: If the code cannot create the sharding directory (for some reason
  # other than it already existing), we simply prints an error message
  # to the console and proceed. #K

    iso8601   = DateTime.utc_now() |> DateTime.to_iso8601()
    dir_name  = String.replace(iso8601, ~r{ : .+ $ }x, "")
    dir_path  = "#{ base_path }/#{ dir_name }"

    unless File.exists?(dir_path) do
      status  = File.mkdir(dir_path)

      case status do
        :ok                 -> true
        {:error, :eexist}   -> true
        {:error, err_type}  ->
          message = "!!! Couldn't create directory #{ dir_name }; " <>
                        "error type is :#{ err_type }."
          IO.puts message
      end
    end

    "#{ dir_path }/#{ iso8601 }.toml"
#   |> ii("file_path") #T
  end

  @spec reorder_bases(l) :: l when l: [String.t]

  defp reorder_bases(inp_bases) do
  #
  # Reorder the bases, so that `meta` (etc) move to the front.

    filter_fn = fn gi_path ->
      base_string   = gi_path |> Enum.join(".")
      front_list    = ~w(meta meta.tags user)
      Enum.member?(front_list, base_string)
    end

    part_1  = Enum.filter(inp_bases, filter_fn)
    part_2  = Enum.reject(inp_bases, filter_fn)
    part_1 ++ part_2
  end

end
