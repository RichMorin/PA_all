# info_toml/emitter.ex

defmodule InfoToml.Emitter do
#
# Public functions
#
#   chef_save/1
#     Save a file of Chef control data, in TOML format.
#   emit_toml/2
#     Emit a TOML file.  Return path to the file.
#   get_chef_toml/2
#     Generate an IO list containing TOML for a Chef build.
#   get_item_toml/2
#     Generate an IO list containing TOML for `item_map`.
#
# Private functions
#
#   fmt_leaf/2
#     Format a leaf node for output.
#   get_file_path/1
#     Generate a file name, based on the current date and time.
#   reorder_bases/1
#     Reorder the bases, so that `meta` (etc) move to the front.

  @moduledoc """
  This module emits maps (e.g., for items) in our flavor of TOML.
  """

  import Common, only: [ ii: 2, keyss: 1]

  alias InfoToml.Types, as: ITT

  # Public functions

  @doc """
  Save a file of Chef control data, in TOML format.
  """

  @spec chef_save(atom) :: String.t

  def chef_save(target) do
  #
  # iex> InfoToml.Emitter.chef_save(:arch)
  # iex> InfoToml.Emitter.chef_save(:debian)

    toml_text   = get_chef_toml(target)
    base_path   = "/Local/Users/rdm/Dropbox/Rich_bench/PA_chef" #!K
    insert      = ".chef.#{ target }"

    emit_toml(base_path, insert, toml_text)
    |> ii(:chef_save) #!T
  end

  @doc """
  Emit a TOML file.  Return the absolute file path.

  Note: The file names generated by `get_file_path/1` are not unique:
  it is possible (though unlikely!) for multiple submission requests
  to come in at the same microsecond.  As a kludgy workaround for this
  eventuality, we write the data in append mode.  With luck, this will
  simply result in a concatenated set of entries.  Of course, if the IO
  subsystem decides to interleave the data, things could get ugly...
  """

  @spec emit_toml(st, st, iodata) :: st
    when st: String.t

  def emit_toml(base_path, insert, toml_text) do

    file_path   = get_file_path(base_path, insert)
    file_name   = String.replace(file_path, ~r{ ^ .* / }x, "")
    heading     = "# #{ file_name }\n\n"
    toml_out    = "#{ toml_text }\n\n\n"

    {:ok, file} = File.open(file_path, [:write, :append])
    IO.binwrite(file, heading <> toml_out)
    File.close(file)

    file_path
  end

  @doc """
  Generate a TOML string for use in controlling a build.  A sample entry
  should look something like this:
  
      [ 'Atril' ]

        actions     = 'build, publish'
        package     = 'debi_pkgs|buster/atril'
        precis      = 'the official document viewer for MATE'
        title       = 'Atril'
  """

  @spec get_chef_toml(atom) :: iolist

  def get_chef_toml(target) do

    item_fn   = fn {main_key, title, precis}, acc ->
    #
    # Return a chef-specific TOML string for this item.

      main_data   = InfoToml.get_item(main_key)
      meta        = main_data.meta
      actions     = meta.actions
      id_str      = meta.id_str

      make_data   = main_key
      |> String.replace_suffix("/main.toml", "/make.toml")
      |> InfoToml.get_item()

      gi_list     = [ :os, target, :package ]
      package     = get_in(make_data, gi_list) || ""

      item_str = """
      [ '#{ id_str }' ]
      
      #{ fmt_leaf("actions",  actions) <>
         fmt_leaf("package",  package) <>
         fmt_leaf("precis",   precis)  <>
         fmt_leaf("title",    title) }
      """

      [ item_str | acc ]
    end

    main_fn   = fn {key, _title, _precis} ->
    #
    # Return true if this is the main file for an item.

      String.ends_with?(key, "/main.toml")
    end

    "Areas/Catalog/Software/"
    |> InfoToml.get_item_tuples()   # [ {key, title, precis}, ... ]
    |> Enum.filter(main_fn)         # Only keep ".../main.toml" tuples.
    |> Enum.reverse()               # Item tuples,  in reverse order.
    |> Enum.reduce([], item_fn)     # Item strings, in reverse order.
    |> Enum.reverse()               # Item strings, in forward order.
  end

  @doc """
  Generate TOML for an item.  Specifically, create an IO list containing
  TOML for `item_map`.  Because we want the result to be attractive and
  readable, we spend some effort on formatting.  For example, we align the
  equal signs (=) and use `gi_bases` to control the order of presentation.
  """

  @spec get_item_toml([ [atom] ], ITT.item_map) :: iolist

  def get_item_toml(gi_bases, item_map) do

    leaf_fn     = fn gi_base ->
    #
    # Fold in formatted TOML for leaf nodes

      base_str  = Enum.join(gi_base, ".")
      part_hdr  = [ "\n[ #{ base_str } ]\n\n" ]
      part_map  = get_in(item_map, gi_base)

      reduce_fn = fn key_atom, acc ->
      #
      # Return a list of formatted TOML for a leaf node.

        leaf_val  = part_map[key_atom]
        key_str   = to_string(key_atom)
        
        if is_map(leaf_val) do
          acc
        else
          [ fmt_leaf(key_str, leaf_val) | acc ]
        end
      end

      part_map
      |> keyss()
      |> Enum.reduce(part_hdr, reduce_fn)
      |> Enum.reverse()
    end

    reject_fn   = fn gi_base -> gi_base == [ :address ] end
    #
    # Return true for the :address base.

    toml_body   = gi_bases      # Get a list of get_in-style bases.
    |> reorder_bases()          # Reorder the list, to taste.
    |> Enum.reject(reject_fn)   # Discard :address
    |> Enum.reverse()           # Reverse the order.
    |> Enum.map(leaf_fn)        # Fold in (reversed) additions.
    |> Enum.reverse()           # Reverse the order back again.

    id_str      = get_in(item_map, [:meta, :id_str])
    toml_hdr    = "# #{ id_str }/main.toml\n"

    [ toml_hdr, toml_body, "\n" ]
  end

  # Private Functions

  @spec fmt_leaf(st, st) :: st
    when st: String.t

  defp fmt_leaf(key_str, leaf_val) do
  #
  # Format a leaf node for output.

    padded_key  = String.pad_trailing(key_str, 11)
    key_etc     = "  #{ padded_key } = "

    val_etc     = cond do
      String.contains?(leaf_val, "\n") ->
        tidied  = leaf_val
        |> String.replace(~r{ \r }x, "")
        |> String.trim_trailing()

        "'''\n#{ tidied }\n'''\n"

      String.contains?(leaf_val, "'") ->
        "\"#{ leaf_val }\"\n"

      true  ->
        "'#{ leaf_val }'\n"
    end

    key_etc <> val_etc
  end

  @spec get_file_path(st, st) :: st
    when st: String.t

  defp get_file_path(base_path, insert) do
  #
  # Generate a file name (eg, `2019-02-23T04:44:36.315737Z.toml`), based
  # on the current (ISO 8601) date and time.  If need be, generate a
  # sharding directory based on the date and hour (eg, `2019-02-23T04`).
  # Finally, return the full path name for the file.
  #
  # Note: If the code cannot create the sharding directory (for some reason
  # other than it already existing), we simply prints an error message
  # to the console and proceed. #!K

    iso8601   = DateTime.utc_now() |> DateTime.to_iso8601()
    dir_name  = String.replace(iso8601, ~r{ : .+ $ }x, "")
    dir_path  = "#{ base_path }/#{ dir_name }"

    unless File.exists?(dir_path) do
      status  = File.mkdir(dir_path)

      case status do
        :ok                 -> true
        {:error, :eexist}   -> true
        {:error, err_type}  ->
          message = "!!! Couldn't create directory #{ dir_name }; " <>
                        "error type is :#{ err_type }."
          IO.puts message
      end
    end

    "#{ dir_path }/#{ iso8601 }#{ insert }.toml"
#   |> ii("file_path") #!T
  end

  @spec reorder_bases(iolist) :: iolist

  defp reorder_bases(inp_bases) do
  #
  # Reorder the bases, so that `meta` (etc) move to the front.

    front_fn  = fn gi_path ->
    #
    # Return true if the base string is in front_list.

      base_string   = gi_path |> Enum.join(".")
      front_list    = ~w(meta meta.tags user)
      Enum.member?(front_list, base_string)
    end

    {part_1, part_2}  = Enum.split_with(inp_bases, front_fn)

    part_1 ++ part_2
  end

end
