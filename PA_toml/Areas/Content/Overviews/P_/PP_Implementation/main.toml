# con_ove|PP_Implementation/main.toml

[ meta ]

  actions     = 'publish'
  id_str      = 'PP_Implementation'
  title       = "Perkian - Implementation"

[ meta.refs ]

  f_authors   = 'cat_peo|Rich_Morin'
  f_editors   = 'cat_peo|Rich_Morin'

[ about ]

  precis      = "Perkian implementation notes"

  verbose     = '''
This page sketches out my current implementation notions
for creating and distributing [Perkian]{con_ove|PP_Introduction} packages.

### Overview

Creating a turnkey collection of several dozen software packages
is a lot of work.
Creating collections for multiple [operating systems]{ext_wp|Operating_system}
and processor types increases the difficulty, for a variety of reasons.
For example, each OS (e.g., [Linux]{ext_wp|Linux}, [macOS]{ext_wp|MacOS},
[Windows]{ext_wp|Microsoft_Windows}) will have its own default packages,
package management tools, and overall system environment.
Differences in the processor family
(e.g., [AMD]{ext_wp|Advanced_Micro_Devices},
[Intel]{ext_wp|Intel}) and other characteristics
(e.g., [word size]{ext_wp|Word_(computer_architecture)})
also complicate turnkey distribution of software packages. 

Each operating system has its own collection of
default [libraries]{ext_wp|Library_(computing)} and
[utilities]{ext_wp|Utility_software}.
The available compilers and libraries may vary,
along with the file tree layout, configuration files, I/O devices,
processor architecture, etc.
This affects the runtime environment for both
[deployment]{ext_wp|Deployment_environment} and
[development]{ext_wp|Deployment_environment#Development}.

#### Combinatorics

Supporting a large number of packages on arbitrary operating systems,
processor families, and word sizes could yield dozens of combinations,
producing a [combinatorial explosion]{ext_wp|Combinatorial_explosion}
of [complexity]{ext_wp|Complexity}.
Fortunately, if we can abstract away some OS details,
we can cover a large fraction of the interesting targets
by handling a small number of combinations, e.g.:

- Linux on 32-bit ARM (e.g., Raspberry Pi)
- Linux, macOS, and Windows on 64-bit Intel

[Docker]{ext_wp|Docker} containers based on Linux
can be run on any Linux system that has the same processor architecture.
Also, there are ways to run Linux applications on both macOS and Windows.
So, we may be able to ignore everything except major hardware issues. 

#### Build and Deployment

Docker containers can be built for most major operating systems,
deployed via [Docker Hub]{https://hub.docker.com},
and downloaded via the Internet.
Although the container must match the downloading host's OS
and processor architecture, Docker's system of "manifests"
can be used to hide the gritty details.
So, the user (or software running on their behalf)
can request container "foo" and receive the appropriate version.

From the outside, a container acts a lot like an independent host,
connected via a network connection.
On the inside, it looks like some host OS, typically a flavor of Linux.
Although there are hundreds of Linux variants,
they share a common [OS kernel]{ext_wp|Kernel_(operating_system)}.
The [Debian]{ext_wp|Debian} family of Linux distributions, for instance,
is popular, robust, and has great build tooling.

If the desired host platform runs (or can emulate) a Linux variant,
we can create and deploy Debian-based containers
for each hardware platform we wish to support.
So, for example, we might only need to build containers for
32-bit ARM devices (e.g., the Raspberry Pi) and
64-bit Intel devices (e.g., typical personal computers).

The Docker build process is based on text-based
[Dockerfiles]{https://docs.docker.com/engine/reference/builder}.
These combine an overall syntax and structure
with OS-specific build commands.
Fortunately, a Unix-style "shell" and some common commands
are available for all the operating systems we have in mind.
So, a single Unixish Dockerfile should handle most of our targets.
We can even abstract some picky details
by using [Chef]{ext_wp|Chef_(software)} as high level build tooling.

Docker Hub and [GitHub]{ext_wp|GitHub} each provide
convenient and reliable ways to collect and distribute packages,
So, all we have to do is push our results and back away slowly.
The result (it says here :-) is a suite that can handle a range
of package building and distribution challenges.

### Details

At a high level, here are the tasks involved:

- Collect package information on Pete's Alley.

- Use [TOML]{ext_wp|TOML} to encode package "wish lists".

- Use Chef to automate the build process:
  - Assume a target OS in the Debian family.
  - Invoke Docker via the Docker Cookbook.
  - Generate containers of desired software sets.

- Distribute files (e.g., containers) via GitHub.

#### Package Management

There are a variety of package management archives, commands, etc.
Some are tied to operating systems, others to programming languages.
For example, [Alacritty]{cat_sof|Alacritty}'s 
[GitHub page]{ext_gh|jwilm/alacritty} lists about a dozen commands
for retrieving and/or building software packages,
including `apt`, `brew`, `choco`, `emerge`, `eopkg`, `nix-env`,
`pacman`, `pkg`, `urpmi`, `xbps-install`, and `zypper`.

Debian's Advanced Package Toolkit ([APT]{ext_wp|APT_(Debian)})
is well known as a reliable way to install software packages.
Given that there are tens of thousands of packages in the archive,
installation for most packages we want will "Just Work".
Finally, numerous versions of Linux (e.g.,
[Raspbian]{ext_wp|Raspbian}, [Ubuntu]{ext_wp|Ubuntu})
are derived from Debian,
so they inherit APT and many other design details.

Chef is a [Ruby]{ext_wp|Ruby_(programming_language)}-based
[configuration _management]{ext_wp|Configuration_management} tool
which abstracts the specifics of tasks such as
building, configuring, downloading, and installing packages.
So, any task which is done for multiple packages or targets
only needs to be described once.

Although a [configuration management]{ext_wp|Configuration_management} tool
such as [Chef]{ext_wp|Chef_(software)} can call the right command
with appropriate parameters, that's only the tip of the iceberg.
If the target OS doesn't have a current and correct set
of installation and configuration code for a package,
we'll need to resolve this deficiency.
Each package management system has its own notion of how to specify
installation and configuration details,
so we'll need a [spanning set]{ext_wp|Spanning_set}
of Chef cookbooks and recipes.

Docker is an
[OS-level virtualisation]{ext_wp|OS-level_virtualisation} ecosystem
which addresses a number of deployment issues.
Lightweight "containers" can be created for a single OS (e.g., Debian)
and deployed on systems ranging from personal computers
through embedded systems to cloud-based servers.
[Android OS]{ext_wp|Android_(operating_system)}, sadly,
is a conspicuous exception to this coverage,
though it still can benefit from APT and Chef.

#### System Environment

All Linux distributions have basically the same
[kernel]{ext_wp|Kernel_(operating_system)},
default [libraries]{ext_wp|Library_(computing)}, and
[utilities]{ext_wp|Utility_software}.
However, that doesn't mean that they have the same runtime environment,
whether for [deployment]{ext_wp|Deployment_environment} or
[development]{ext_wp|Deployment_environment#Development}.
The available compilers and libraries may vary,
along with the file tree layout, configuration files, I/O devices,
processor architecture, etc.

Any given operating system may include some of Perkian's packages.
However, the versions and configurations will vary,
causing both a support challenge and an uneven user experience.
So, our plan is to provide our own versions of many packages,
in addition to any that the OS may provide.

### Summary

Our use case  presents a potentially unmanageable amount
of development, testing, and support.
Fortunately, there are ways to manage this,
using readily available software and other resources.
Stitching these resources together will be a job for custom code
(e.g., [Elixir]{ext_wp|Elixir_(programming_language)},
[Ruby]{ext_wp|Ruby_(programming_language)})
and data files (e.g., [TOML]{ext_wp|TOML}).
See [Perkian - Chef Notes]{con_ove|PP_Chef} for details.

To be continued...
'''

[ zoo ]

  snippets    = '...'
