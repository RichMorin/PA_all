# con_ove|PP_Chef/main.toml

[ meta ]

  actions     = 'publish'
  id_str      = 'PP_Chef'
  title       = "Perkian - Chef Notes"

[ meta.refs ]

  f_authors   = 'cat_peo|Rich_Morin'
  f_editors   = 'cat_peo|Rich_Morin'

[ about ]

  precis      = "Perkian implementation notes on Chef"

  verbose     = '''
Our current prototyping path concentrates
on [Docker]{ext_wp|Docker_(software)} containers, which provide
[OS-level virtualisation]{ext_wp|OS-level_virtualisation}.
So, [Chef]{ext_wp|Chef_(software)} is not critically needed at the moment.
However, we expect to investigate it, for a couple of reasons.
Clearly, we'll need it to support "native" installation
on multiple target platforms.
The [Docker Cookbook]{ext_gh|chef-cookbooks/docker}
should be able to generate any containers we need,
so we might be able to create nearly a univeral set of tooling.

### Approach

Chef cookbooks and recipes are fairly complex pieces of infrastructure;
we certainly don't want to create one for each combination
of package, OS distribution, etc.
Still, we'd like Chef to provide a layer of abstraction
between the list of packages and the OS commands required to install them.
Fortunately, one of the answers to the
[Parameterize chef recipe]{https://stackoverflow.com/questions/
  21910547/parameterize-chef-recipe} question on
[StackOverflow]{https://stackoverflow.com} hints at a way to do this.
The basic idea is to feed in a data structure with the variable data
and have the recipe generate and run the appropriate commands.

In the answer, the data is encoded as a [JSON]{ext_wp|JSON} text string
which is stored in `default['config']` and retrieved from `node['config']`.
However, the information could just as easily be read from a file
and the encoding could use any desired serialization format.
Since we're using [TOML]{ext_wp|TOML} heavily in Pete's Alley,
it makes sense to encode the necessary data in that format.

### Example

Let's assume that we're building a distribution based on
[Debian]{ext_wp|Debian} and that we wish
to include the [Atril]{cat_sof|Atril} package.
All of the needed information should be available
in the item's `main.toml` and `make.toml` files.
Here are some (science fiction!) entries
for our TOML control file (e.g., `debian.toml`):

    [ 'Atril' ]

      actions     = 'build, publish'
      package     = 'ext_pd|stretch/atril'
      precis      = 'the official document viewer for MATE'

A naive recipe for adding native packages to a Debian-based distribution
might look something like this:

    require 'toml'
    items   = TOML.load_file('debian.toml')
    keys    = items.keys.sort

    keys.each do |key|
      item  = items[key]
      puts "#{ key } - #{ item['precis'] }"
      pkg_name  = item['package'].sub(%r{^.+/}, '')
      package pkg_name
    end

### Complications

In practice, I expect things to be quite a bit more complicated.
For example, there may be other commands or recipes
that will need to be run before or after the package installation.
In some cases, such as [GitHub]{ext_wp|GitHub} repositories or
[RubyGems]{ext_wp|RubyGems}, there may not _be_ a Debian package.
Finally, as mentioned above, we may be creating Docker containers
that _contain_ a given package.
Still, it should be possible to create appropriate recipes,
assuming that we can find out what needs to be done.

To be continued...
'''

[ zoo ]

  snippets    = '...'
